name: Tea Guestbook Auto-Reply

on:
  issues:
    types: [opened]

permissions:
  issues: write

concurrency:
  group: tea-guestbook-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  reply:
    runs-on: ubuntu-latest
    steps:
      - name: Reply + title + close + lock (Tea Guestbook)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            // Fetch the issue
            const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });

            const rawBody = issue.body || "";
            const body = rawBody.replace(/\r\n/g, "\n"); // normalize CRLF -> LF
            const user = issue.user?.login || "friend";
            const title = issue.title || "";

            // --- Stable detection (do NOT depend on labels) ---
            const titleLooksLikeTea =
              /^\s*â˜•/u.test(title) ||
              /\btea guestbook\b/i.test(title) ||
              /\bcup of tea\b/i.test(title);

            // Secondary detection: contains "how are you" + tea-related
            const bodyLooksLikeTea =
              /how\s+are\s+you/i.test(body) &&
              /\btea\b/i.test(body);

            if (!(titleLooksLikeTea || bodyLooksLikeTea)) {
              core.info("Not a Tea Guestbook issue. Exiting.");
              return;
            }

            // --- Idempotency: don't double comment ---
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const alreadyReplied = comments.some(c =>
              (c.user?.type === "Bot" || /\[bot\]/i.test(c.user?.login || "")) &&
              /\bYour tea is ready\b|\bcup of tea to-go\b/i.test(c.body || "")
            );

            // --- Robust extractor: find heading line matching regex, return first non-empty line under it ---
            function answerUnderRegex(questionRe) {
              const lines = body.split("\n");
              let start = -1;

              for (let i = 0; i < lines.length; i++) {
                const t = lines[i].trim();
                const headingText = t.replace(/^#{1,6}\s*/, ""); // accept "### How are you?"
                if (questionRe.test(headingText)) {
                  start = i + 1;
                  break;
                }
              }
              if (start === -1) return "";

              for (let j = start; j < lines.length; j++) {
                const v = lines[j].trim();
                if (v.startsWith("#")) break;    // next heading reached
                if (!v || v === "---") continue; // skip blanks/separators
                return v;
              }
              return "";
            }

            // Extract answers (robust to wording tweaks)
            const tea =
              answerUnderRegex(/(which|what)\s+.*flavor.*tea/i) ||
              answerUnderRegex(/flavor.*tea/i) ||
              "";

            const mood =
              answerUnderRegex(/how\s+are\s+you/i) ||
              answerUnderRegex(/how\s+are\s+you\s+feeling/i) ||
              "";

            // Build mood-based reply
            const teaText = tea ? `Your **${tea}** is ready.` : `Your tea is ready.`;

            // Option B messages (replaces the old switch)
            let msg;
            switch ((mood || "").trim().toLowerCase()) {
              case "great":
                msg = `â˜• Hey @${user} â€” okaaaaay! Feeling great is a win. ${teaText} Donâ€™t spill that vibe. ðŸµðŸ˜Œ`;
                break;
              case "good":
                msg = `â˜• Hey @${user} â€” We take â€œgoodâ€ all day. ${teaText} Sip slow, enjoy the moment. ðŸ˜Œ`;
                break;
              case "meh":
                msg = `â˜• Hey @${user} â€” feeling meh? Copy. ${teaText} This cup is for emotional support. ðŸ«¶ðŸ½ Take care of yourself.`;
                break;
              case "not so great":
              case "not great":
                msg = `â˜• Hey @${user} â€” oof. ${teaText} Weâ€™re not fixing everything today; just focus on getting through it. ðŸ«‚`;
                break;
              default:
                msg = mood
                  ? `â˜• Hey @${user} â€” mood noted: **${mood}**. ${teaText} Weâ€™re still proud of you for showing up. ðŸ’›`
                  : `â˜• Hey @${user} â€” ${teaText} Appreciate you stopping by. ðŸ’›`;
            }

            // --- Timer: wait ~1 second after the workflow starts ---
            await new Promise(resolve => setTimeout(resolve, 1000));

            // --- PRIMARY GOAL: comment ---
            if (!alreadyReplied) {
              try {
                await github.rest.issues.createComment({ owner, repo, issue_number, body: msg });
                core.info(`Posted comment. tea="${tea}" mood="${mood}"`);
              } catch (e) {
                core.error(`createComment failed: status=${e.status || "unknown"} message=${e.message}`);
                core.error("If status=403: Settings â†’ Actions â†’ General â†’ Workflow permissions â†’ Read and write permissions.");
                throw e;
              }
            } else {
              core.info("Already replied; skipping duplicate comment.");
            }

            // --- Title update (best effort) ---
            const desiredTitle = `â˜• A cup of tea to-go for @${user}`;
            if (title !== desiredTitle) {
              try {
                await github.rest.issues.update({ owner, repo, issue_number, title: desiredTitle });
                core.info("Updated title.");
              } catch (e) {
                core.warning(`Title update failed: status=${e.status || "unknown"} message=${e.message}`);
              }
            }

            // --- Close (best effort) ---
            if (issue.state !== "closed") {
              try {
                await github.rest.issues.update({ owner, repo, issue_number, state: "closed" });
                core.info("Closed issue.");
              } catch (e) {
                core.warning(`Close failed: status=${e.status || "unknown"} message=${e.message}`);
              }
            }

            // --- Lock (never fail the workflow) ---
            try {
              await github.rest.issues.lock({ owner, repo, issue_number, lock_reason: "resolved" });
              core.info("Locked issue.");
            } catch (e) {
              core.warning(`Lock failed (ignored): status=${e.status || "unknown"} message=${e.message}`);
            }
