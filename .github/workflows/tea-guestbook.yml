name: Tea Guestbook Auto-Reply

on:
  issues:
    types: [opened]

permissions:
  issues: write

concurrency:
  group: tea-guestbook-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  reply:
    runs-on: ubuntu-latest
    steps:
      - name: Reply + title + close + lock (Tea Guestbook)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            // Fetch the issue
            const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });

            const rawBody = issue.body || "";
            // Normalize line endings for consistent regex behavior
            const body = rawBody.replace(/\r\n/g, "\n");
            const user = issue.user?.login || "friend";
            const title = issue.title || "";

            // --- Stable detection (do NOT depend on labels) ---
            // Your Tea issues already use the ☕ title pattern; keep that as primary.
            const titleLooksLikeTea =
              /^\s*☕/u.test(title) ||
              /\btea guestbook\b/i.test(title) ||
              /\bcup of tea\b/i.test(title);

            // Secondary detection: must include "How are you?" prompt somewhere
            const bodyLooksLikeTea = /\bHow are you\?\b/i.test(body) && /\btea\b/i.test(body);

            if (!(titleLooksLikeTea || bodyLooksLikeTea)) {
              core.info("Not a Tea Guestbook issue. Exiting.");
              return;
            }

            // --- Idempotency: don't double comment ---
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const alreadyReplied = comments.some(c =>
              (c.user?.type === "Bot" || /\[bot\]/i.test(c.user?.login || "")) &&
              /\bYour tea is ready\b|\bcup of tea to-go\b/i.test(c.body || "")
            );

            // --- Robust section-answer extractor ---
            // Finds a heading line containing the question, then returns the first non-empty line after it.
            // Works even if GitHub inserts extra blank lines.
            function answerUnder(questionText) {
              const q = questionText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // escape for regex
              const re = new RegExp(
                // start of line + optional markdown heading markers + question
                String.raw`(?:^|\n)\s*(?:#{1,6}\s*)?${q}\s*\n([\s\S]*?)(?=\n\s*(?:#{1,6}\s*)|\n\s*$)`,
                "i"
              );
              const m = body.match(re);
              if (!m) return "";
              const block = m[1] || "";
              // first non-empty, non-separator line
              const line = block
                .split("\n")
                .map(s => s.trim())
                .find(s => s.length > 0 && s !== "---");
              return line || "";
            }

            // Extract by robust heading match (ignores minor wording changes / spacing)
const tea = answerUnderRegex(/which\s+flavor.*tea|what\s+flavor.*tea/i) || "";
const mood = answerUnderRegex(/how\s+are\s+you/i) || "";

function answerUnderRegex(questionRe) {
  const lines = body.split("\n");
  // Find a line that looks like a heading containing the question
  let start = -1;
  for (let i = 0; i < lines.length; i++) {
    const t = lines[i].trim();
    // accept "How are you?" or "### How are you?" or "# How are you?"
    const headingText = t.replace(/^#{1,6}\s*/, "");
    if (questionRe.test(headingText)) {
      start = i + 1;
      break;
    }
  }
  if (start === -1) return "";

  // Return first non-empty line after the heading (skip blanks/separators)
  for (let j = start; j < lines.length; j++) {
    const v = lines[j].trim();
    if (v.startsWith("#")) break;   // next heading reached
    if (!v || v === "---") continue;
    return v;
  }
  return "";
}
switch ((mood || "").trim().toLowerCase()) {



            // Build mood-based reply
            const teaText = tea ? `Your **${tea}** is ready.` : `Your tea is ready.`;

            let msg;
            switch (mood.toLowerCase()) {
              case "great":
                msg = `☕ Hey @${user} — love that for you. ${teaText}`;
                break;
              case "good":
                msg = `☕ Hey @${user} — glad to hear it. ${teaText}`;
                break;
              case "meh":
                msg = `☕ Hey @${user} — “meh” days count too. ${teaText} Hope it softens a bit.`;
                break;
              case "not so great":
              case "not great":
                msg = `☕ Hey @${user} — sorry it’s heavy. ${teaText} One gentle win today is enough.`;
                break;
              default:
                // If the mood value is something unexpected (or blank), still respond gracefully.
                msg = mood
                  ? `☕ Hey @${user} — I hear you (${mood}). ${teaText}`
                  : `☕ Hey @${user} — ${teaText}`;
            }

            // --- Timer: wait ~1 second after the workflow starts ---
            await new Promise(resolve => setTimeout(resolve, 1000));

            // --- PRIMARY GOAL: comment ---
            if (!alreadyReplied) {
              try {
                await github.rest.issues.createComment({ owner, repo, issue_number, body: msg });
                core.info(`Posted comment. tea="${tea}" mood="${mood}"`);
              } catch (e) {
                core.error(`createComment failed: status=${e.status || "unknown"} message=${e.message}`);
                core.error("If status=403: Settings → Actions → General → Workflow permissions → Read and write permissions.");
                throw e;
              }
            } else {
              core.info("Already replied; skipping duplicate comment.");
            }

            // --- Title update (best effort) ---
            const desiredTitle = `☕ A cup of tea to-go for @${user}`;
            if (title !== desiredTitle) {
              try {
                await github.rest.issues.update({ owner, repo, issue_number, title: desiredTitle });
                core.info("Updated title.");
              } catch (e) {
                core.warning(`Title update failed: status=${e.status || "unknown"} message=${e.message}`);
              }
            }

            // --- Close (best effort) ---
            if (issue.state !== "closed") {
              try {
                await github.rest.issues.update({ owner, repo, issue_number, state: "closed" });
                core.info("Closed issue.");
              } catch (e) {
                core.warning(`Close failed: status=${e.status || "unknown"} message=${e.message}`);
              }
            }

            // --- Lock (never fail the workflow) ---
            try {
              await github.rest.issues.lock({ owner, repo, issue_number, lock_reason: "resolved" });
              core.info("Locked issue.");
            } catch (e) {
              core.warning(`Lock failed (ignored): status=${e.status || "unknown"} message=${e.message}`);
            }
